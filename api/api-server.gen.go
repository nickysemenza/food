// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"VIwzAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
