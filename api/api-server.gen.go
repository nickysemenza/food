// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
