// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/foods/search", wrapper.SearchFoods)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/meals/:meal_id", wrapper.GetMealById)
	router.PATCH("/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+1cAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
