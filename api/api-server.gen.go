// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/foods/search", wrapper.SearchFoods)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/meals/:meal_id", wrapper.GetMealById)
	router.PATCH("/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
