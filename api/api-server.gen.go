// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "data_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "data_types", ctx.QueryParams(), &params.DataTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter data_types: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET("/foods/bulk", wrapper.GetFoodsByIds)
	router.GET("/foods/search", wrapper.SearchFoods)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.GET("/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST("/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/meals/:meal_id", wrapper.GetMealById)
	router.PATCH("/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"aefCYwAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
