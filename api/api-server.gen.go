// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/foods/search", wrapper.SearchFoods)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+Qc247bNvZXCHWBTQDNOMl298Fv06TpzqItgkmAPgQDlxaPLXYkUiEpe9zA/77gTaIk",
	"SpYnk2LaPmVskofnznNzPicZLyvOgCmZLD8nFRa4BAXCfCpoSdU7/ZX+REBmglaKcpYskw85IFaXaxAS",
	"8Q2iCkqJFEcCVC3YZZImVG/7VIM4JGnCcAnJ0kJM0kRmOZTYQt3gulDJ8tWLNCnxPS3rMln+W3+gzH54",
	"mSbqUOnjlCnYgkiORwtxAjcJWGQ5MvejZ3rz8zGkzD9pIuBTTQWQZKlEDSGO7napBGVbcznfbCScZk2H",
	"M/KOVmgNGy4ASYWFomyrv894UUCmkMoBCZB1oZAENYasvbnDwoZRLyKMOvqdRqJXtcpvQFZG1oJXIBQF",
	"s/LbXkVITZNagggW+Po3yJThQcuvj3ZXaoDcpv29afKdwIwAecs5GbJLccKTtIfOWp9Y8T3r3N6itbYQ",
	"VxvOySrDCrZcHKI7c15LyHlBVhLETn8Z20XZVgCh3g4G6+7sStLfQW/YcFFilSwTwut1odXHHbGC7x9Z",
	"1YyquCqFbOzcEoMQY+73QnDDJLjHZVUY9EqQEm/1vve8BJVrVdsDU2gvuCWoy+5m/ykM/cYYInHxXiHF",
	"K1TADgqkpRUXNZAVZRuuP/9DwCZZJt8sWte0cCq8CBXpmCah4KeO6f2v/d5jmhCs8MriP6KNwLRBfUw2",
	"vGYE67WVQ14aJvtPJRZ3oFY4+1RTSQ2MNJG12MFhtWGEyOZYvV51j+KtoFldqFrgog9ArArY4uzg94bq",
	"HvC+1c8OEX2aNPko/CoCYEOyFY2I7+2b1+iaJEPPkiasVqKxmCgXje+bI5yfHSgN1l2EhcCHgf45NLsE",
	"hwIN0RpT0teB2szwRRkn8DCmfqFUerQbPLpAxyhs+DmPQlzy2m6e4dcMrytOu64yohenBN8KvUdoAyD1",
	"mHVvjVH9A+fbAt7lXPGYD9qaZVSZ9YEHwhJWtSiGB6t6XdAM0VL7vIiA10UtVjmW+fCoXkJmKXIuE4AV",
	"RMxtnwNDVKE9lkjhO9Ba0coEK7hQtIyikgPd5hGB2+9RdR9Cokz959uoUcd8ACWxC/eUqAjd5uuZ1/Xk",
	"bu5phNFyyd/VEHlCAeRVsa4jgRlmCOsVlHGmMGX6Vfw1OPfrQDPmc6MSnNSZGlGjYDFyVlFVxJ4i83Ua",
	"jckyLCMn/MIpT2JJcOC7yHkQMRZfN0FSxMQYCpYfzkcb5vb3tqCRi9ZnEGh2TtPxBhSmxbnUZDktiAA2",
	"hadEKscKYQFI47XDhYU060kcIDh4FsOIdT60xLApoxVE3uwbu4AEbEAAy0x6klOJaMiJWfhbUGO492XV",
	"go8J60cq1TBdsYnkgIb/8j0qMTu4rGsPQudUn2qQCgjacGEpqjruPPB+LrsaezWHBzSkVeZfz14eyBUu",
	"gkxQ75UI7zAtcOdt7cNzb+0A4C9aoxw8vdGJR0YhKX37XNQsu3AmuJQIF4XF9bTHDtFNm+w+vDptM9aA",
	"VzFB/wQ4ZomoBFykaJ/TLEdrQcnW6KjVVcXtky6HIY2CFVaP+cB+qQ87FUs4QrS3nGNjYcATcQ+Bmc8C",
	"p7lvzfa0wTbONfVsbrAfE6wDHRGvRdR4y39qyxRKKyQ2YkfPsF/XvhTJCjK6oRmyYeHzgdTLulC0KmjM",
	"eqYlPxruigbz+R6vnzS3WDXwYow6M2qn5AxHFdfJ7vYgwmBUrc45MqEiLawYze/wljId5em0RQ4d/cZ/",
	"PTuXjFlDCQqfOmsemuNxCsfrbpWoJ47u4qM99I+Eu7bCCNal/3q2l/iKOL5rXGAfybngH9eNTiJ703rY",
	"h2N7rpuecNEDTE/63D1VOZL1OugBPDxw34GQlLNIYKnjCZUD8ju0f7fFboPf14gpG2TMs307ypzR+B8J",
	"2FENwj5GDaoP5Q6VqwIrkGrlUIu+TyrX4ZhAjCv9UlFp+FRyqTQGOvvxp5sr1pwXgNm4i3eyjqdNafKp",
	"xkxRFamFueozanbMqh9IyFRcDfzKl4j/vYURc0EO3cjFrC5RszqPCF6LLJYjrTm/0wLaw1pSZSLkc7A3",
	"YGPI+/ZAXAJmddzkhgfdwoDTDyrIOM0J1MDh04h63L68vCIGJhVUiLIugl3zIrXA/vgUdz/QEm4w28J5",
	"YXrvwe4euZ8rWkdiN8keJutSiXrMMs6/q4E2L1jvXN8lfEJ2VltjfkpAIDaU4RLQRvASPaOXcIm0kSyc",
	"hQxD9Mr1mXrJkU5nbdC9cHqFntGNgfX83JrZ9MlohS5amRt/VH8RuKpiScY5bytpHp9z3r25+t3TA3fZ",
	"6Hv43vTLb0z/OWqutp/uGtR7S79Py109NSwVSYQZ8Xn68OGcMr0POYSAzi+anciHh7e1aJ7hzb0OzIrF",
	"hl5isnZImc52KdsWgJw5DCscRAOnu4gVtEsR/W+bPb1DvtUyIyneClxGeLm3vQbKkN0wC9ZDHPZ5unBH",
	"WbTVghXSS6YAFtY4ffO3jVBiJcoWL25AxqpXzUosXuOC6lQickzgPSooA1OXQ88qARe0rLhQC5kJXEHU",
	"rz2kUGH60lJRVSv46o9gPMiJBzexV8zrlBHn7ZSRtc9jxMrap3CWmZ2jnhP3houzqA0PxIhtg57YI6QX",
	"TPhHS9ABa1A781FVs/yMMk09Z0RGKmr4Pu4z3ayWK8VpYA6GeX2xReF5NLwuKRuBaSeZYjBN6R6QKS2n",
	"iG5MjjRxS78ER5mZ1riP8NJmLbWg6vBe67NrCgMWIK5q2+O0n956b/a/Xz74ESxj1Ga1xSJXqrKzV36o",
	"paAZMNuyc4NcP11/COKY5AdeC4KsdaI3WOG1beQ1MX7y8vLF5QvrboDhiibL5F/mqzSpsMoN0gvT3zR/",
	"bm0fQ8vSiPuaJEvTTLkqiiu7S7NIVpxJS/GrFy/suANTzsXiqipoZo4vfpNWrdu5s95z1Nw8lGtBpa3q",
	"+nvPLc24ju6Mp/bYH7tIroqibbo4FGy4aocC7KCGm0I8g/wp1O1MVgSZmsF9BZkCgsDt0T64LLE4OPmY",
	"/kvDKYV1SvvRs/dW719gp5UVlxGP+t7YjE2w+AZpZZTLxYLADgotMXlpCb/MeLmgBExat5B0yy4o04H7",
	"Yo2zO2DkQt/zjdR/qRwuKLlQ/A7YheIXB16LC52fGrXvKpm2mR/51lhcOFD6sY+oFTBycy2xaUe3NH80",
	"8/YLdXpKqM3wZEzJamWCY3PzE9Ao58+S5cfbUL8cx410UIaLQks61LJa5VofLIpO20wJfmETgFHPYvMH",
	"W8QfiD1GWLtlEU7THtOT24Ox5Bm72znhr6ocvT5GRFDvwwxKPiWv4zDbOOF5ZbDDhoEKfLbTd8dRJfgB",
	"lCb/u4OZGJy0ff0sbEiGXKxjSgBmxMdZfjPod9L22yf/a8rXdpaGrP3eM9bfjBRHGO1wQYkfPXhKst6C",
	"DpvevnmNgClxQOuDFUFE6L0kfTSguO7k6n+Y6f8h1hzSFnP7dg6jk0A2Fp4mOWDifktxf8HgPlpZKSi7",
	"00qjw1u9pwHZUjf14h2fYvjSLd943erUHY9pE750Veq1mfrrKpUzpO84OTwakWGyOqTUYiERDiW7PqAK",
	"HwqOySW6trV1SswLg+CeSiVTRJXljBy4ruNAX1/+QbT8DPvigNw0ZVjqeEKqY/ndYfeo5vSc0+Jz+0E/",
	"T4uMsx0ItVJ81RZFRpTNbm3594HfNM2IU+8XJb7D0h2RG75mHQS/MKB9PK3pDa2M6Y1lEfhq7pPSGoub",
	"RJiFdmqeYIttiuqKYPNbK+2Y/OAYgQoY0d9yhqj5tZXXtaAYfJbWlSC2E5r2k16efCrnKZgmzlyFKDOz",
	"7I+vbg/ztWMV/hXtDfAMCmclvr+2i+53f+7Ty9mTo+aO2xnFgG5vAVFiZgjXYFlKnpDT7mEKOxAH90Mu",
	"LB26VgWekD0aJbdTC5XgO0o6nRzf7l1zcjCo240mnJvy9c2M0mgIaoeb/mrBp6VqMuy0rHmKIWDpROLF",
	"aj9bgbYzWqMSfdeM9f6lROrImpSp485TFGozbO2l6sd+jViDHuuoXG/ajvBfSrCerlHJEmQeMZvYeR78",
	"bRPElgX9sOtUYtgq0NdICnut/am80A16PNmc8CQp3bTwCQb3PiVs+vBDXQnczuKz/eNUhdLyZW6Nsg3B",
	"/Q8VzP9xISjsIB58N1g8mcbFSU34sxUxr9mGm19zBW3tE0oyq33xt+xcdCa//ox9C5/TY0ZmFB7TUDG6",
	"rbJu0//jrWa77XFaZTCTg6a5v1wsCp7hIudSLb999e2rBa5o0kdfWbMJD8rlwjRTLhnN7g4SSmC/Y9OI",
	"jQGoBCfJ8fb4/wAAAP//S3ZZJ6dHAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
