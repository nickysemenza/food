// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/foods/search", wrapper.SearchFoods)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/meals/:meal_id", wrapper.GetMealById)
	router.PATCH("/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"C8Or7Z+XC/xFMn/+9f1/AgAA//94IDZCbVQAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
