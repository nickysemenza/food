// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Login
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RaX2/buhX/KgS3hw1Q4zS324NfLnrXrsvQDkGbog9BENDSscVGIhXyyI5X+LsP/COJ",
	"kmhb6ZrN6H1KJJKHv/OHv3N45G80lWUlBQjUdP6NVkyxEhCUfSp4yfHKvDJPGehU8Qq5FHROr3Mgoi4X",
	"oDSRS8IRSk1QEgVYK3FGE8rNtIca1JYmVLAS6NxJpAnVaQ4lc1KXrC6Qzi/OE1qyR17WJZ3/xTxw4R5e",
	"JhS3lVnOBcIKFN3tEiqXSw3H0fXA6XtekQUspQKikSnkYmXep7IoIEWCORAFui6QaMB9Sride1q0WM8j",
	"WHfNTGvU1zXmH0FX1txKVqCQgx35ukHzx6/XqLhY0V1Caw0qGJCLr5CitYGCh5oryOj8xs1KrJDbZDg3",
	"oW+Vkmq8ZyozMH+XUpUMHexfLuhYi4SWoDVbQQTiAImV2c2PoXkn5aqAq1yiHDvvNVnZYVLZ8WQAecE0",
	"3NWqGC+s6kXBU8JLs20yNmSqgKHBOFy4yUEQjmTDNEF2D4ImnUUyhvACeRkVySPSeDaeOTCRndIq0iGL",
	"2epSrBRkHARGTCVIMDy0VAzc58+Xb2KKuNgezu6EEzthkl525mFN3gAyXjxVnzTnRaZAHMKpCeYMCVNA",
	"DK41K5wkywFm4R8VLOmc/mHWMd/MH89ZsPeuxc+UYlvr654jpstRkPLKadBH/dENEAVLUCBSy0Y514SH",
	"NpiE3Ikaox76pxMcc9B7rnHMEY60R+j/ITekZGLr6XUDypDnQw0aISNLqZwuVe8wBnziaXQkF2UmowuM",
	"pLtU1rGDcC2RFQHlm7masDXjBVsUsF+eWzIW+MVEkZdnJnrH6KgkNLtPhebMxVIltSasKBxWGk1yoe9C",
	"uEmbScOtky41BbaKOfoDsOLJxMsQ7hj+P9hzHz0dI3yrh6PCKYcozEpHT1LLdEljmHa/mMWv2IoLw/EB",
	"VY2PGu8PPpG0PKtGqKsEZMfk2MO/2x3CbsImgrpsXk/Ca2Pv+TBetT4fgpwq/ofHzX6wH7vU8P1og/zy",
	"3+aKEVI/N0IVbtdnqDmc4D31RkIfaiaQ43a8UINamxTazkh6Ze1fX0W526+KpGdRl6QdnSZL1iqNqLSQ",
	"8p5IRTaw0BzhV5JBpSA1EfBrTEdH6iUXNcbqBp8hJwCqRSxzN4ayo9NLusD2XvLt3ojZW+D5uCEbjjnR",
	"9SK4fw5DSbWxNy2aNaRmFx1T2I2Y9OvueD52n3BePjkZRxNDi6I5mAes1MiMmEkjVISLPtzvP2qDxNJf",
	"9DjVEh7vsTJZo6r3ueLpe7XSoklj3xlpq1M/wxrSGtWUKDohrKqUfOQlQyi25E/mTJEXpGT3vtRjRDGx",
	"gj9POWixI9MgGxik74pYaIyNfPC6wwVhRHNh6jYfe+PKLTPC+TpCTd1QJGpYGS9p/fuwzJN1r8z2deou",
	"oSvFyoh/NsBXORr0bsIkWd8X8U+7rd1zEe0QMCRmyFbw4fUMRF0ap3ecErtjdbikFRkrv9uRdtVCygKY",
	"6JL8dDKMM/90xm+8Ys2RNAu7aDkYud2RjYRudxgmxe7TfH5g53BwkgnCBWN1XcKpFcftJ2N935wCpkC9",
	"rjHvnv7eBPY/v1w3XUPrXTvaYckRK9cu5GIp3c07BaGt133v8cPltaVBjoV5fCdrlRHndfKGIVswbWJw",
	"DUo7rV+enZ+du7gDwSpO5/QX+8rcETG3oGfM462ku/8b+zPryswkoxrz93LFrW+CBvHN0MKuDia+/xdr",
	"nfqhztSoaggbqUO33JrJupJCO/tenJ+7tqVAf7JZVRU8tWhnX7VzfCfv0GFpO7HW5oMEXGNOmp2pHfZ9",
	"6h+0uevHRnauBTxWkCJkBPychOq6LJna0jl1jjDvZoOcvoKI78wdIbxxjjwYw9hNmYVd9l1ydHrwxeBZ",
	"XRe9Tcfc6Ho3Pc72HX5jixxY5r91PL4Q8BjrsJKCi3uC0hYQZk4rstPuUATvTil4uEbbcgpDx9x3o+f+",
	"b7Yp3Y8e3+D7TWbbH6ZNmH/HKjkUph4LXLjYkoptC8myM3LpanqTE2aGZgg8co06IRydEfSIcXaj0Hz5",
	"P9LmX7AptsS3+8NC4oSixFm8Z3CTpJi5I9/0y1fLQ237Zy8Dub7Rz8Y9TquDrONMc4oM4JEZ/3Xdrr0O",
	"9E21n82DXq2DLvTWOUUfNtCME4Mm4F4vNt3Gn82NjV57/ZgR2zBwSbuxwe82+XcmaDi9eXN7pBboAug5",
	"6oBe5/BgJeB7iCdcBRzTpV8HqPbafnI1QNvWGMdKQDuzb+6fO57t9lLQO/AM9Nv2Mjt2l7zOgfCs37D1",
	"vy9SHNbtBdNcYrv7ZYviZC6ZxwLhbeOFBoFRkpE1K3jWfE4/pcC4FEtpP+4zoitI+ZKnB2MkaJNYL4cN",
	"kptbY3oNat3EgP1Zj22EzGezQqasyKXG+auLVxczVnE6BIvOOuFCPZ/NllJmZ4Kn91sNJYh/s7NUllEB",
	"lZIZ3d3u/hMAAP///GmAmQknAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
