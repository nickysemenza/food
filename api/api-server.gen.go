// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"3T3s/hcAAP//eOUMvhQsAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
