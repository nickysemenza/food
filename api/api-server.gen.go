// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
