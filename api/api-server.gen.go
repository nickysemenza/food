// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
